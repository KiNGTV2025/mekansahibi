import logging
import sys
import os
import asyncio
from aiohttp import web

# Aggiungi path corrente per import moduli
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from services.hls_proxy import HLSProxy
from services.ffmpeg_manager import FFmpegManager
from config import PORT, DVR_ENABLED, RECORDINGS_DIR, MAX_RECORDING_DURATION, RECORDINGS_RETENTION_DAYS

# Only import DVR components if enabled
if DVR_ENABLED:
    from services.recording_manager import RecordingManager
    from routes.recordings import setup_recording_routes

# Configurazione logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)

def create_app():
    """Crea e configura l'applicazione aiohttp."""
    ffmpeg_manager = FFmpegManager()
    proxy = HLSProxy(ffmpeg_manager=ffmpeg_manager)
    
    # ‚úÖ Increased client timeout for HF Space
    app = web.Application(client_max_size=1024**3)  # 1GB max
    app['ffmpeg_manager'] = ffmpeg_manager
    app.ffmpeg_manager = ffmpeg_manager

    # Initialize recording manager for DVR functionality
    if DVR_ENABLED:
        recording_manager = RecordingManager(
            recordings_dir=RECORDINGS_DIR,
            max_duration=MAX_RECORDING_DURATION,
            retention_days=RECORDINGS_RETENTION_DAYS
        )
        app['recording_manager'] = recording_manager

    # Registra le route
    app.router.add_get('/', proxy.handle_root)
    app.router.add_get('/favicon.ico', proxy.handle_favicon)
    
    static_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')
    if not os.path.exists(static_path):
        os.makedirs(static_path)
    app.router.add_static('/static', static_path)
    
    app.router.add_get('/builder', proxy.handle_builder)
    app.router.add_get('/info', proxy.handle_info_page)
    app.router.add_get('/api/info', proxy.handle_api_info)
    app.router.add_get('/key', proxy.handle_key_request)
    app.router.add_get('/proxy/manifest.m3u8', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/manifest.m3u8', proxy.handle_proxy_request)
    app.router.add_get('/proxy/mpd/manifest.m3u8', proxy.handle_proxy_request)
    app.router.add_get('/proxy/stream', proxy.handle_proxy_request)
    app.router.add_get('/extractor', proxy.handle_extractor_request)
    app.router.add_get('/extractor/video', proxy.handle_extractor_request)
    app.router.add_get('/proxy/hls/segment.ts', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/segment.m4s', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/segment.mp4', proxy.handle_proxy_request)
    app.router.add_get('/playlist', proxy.handle_playlist_request)
    app.router.add_get('/segment/{segment}', proxy.handle_ts_segment)
    app.router.add_get('/decrypt/segment.mp4', proxy.handle_decrypt_segment)
    app.router.add_get('/decrypt/segment.ts', proxy.handle_decrypt_segment)
    app.router.add_get('/license', proxy.handle_license_request)
    app.router.add_post('/license', proxy.handle_license_request)
    app.router.add_post('/generate_urls', proxy.handle_generate_urls)

    # ‚úÖ IMPROVED: FFmpeg stream handler with better buffering
    async def proxy_hls_stream(request):
        """Serve segments generated by FFmpeg with optimized buffering"""
        stream_id = request.match_info['stream_id']
        filename = request.match_info['filename']
        file_path = os.path.join("temp_hls", stream_id, filename)

        # Security check
        try:
            if not os.path.abspath(file_path).startswith(os.path.abspath("temp_hls")):
                return web.Response(status=403, text="Access denied")
        except:
            return web.Response(status=403, text="Access denied")

        # Notify manager to keep stream alive
        if hasattr(app, 'ffmpeg_manager'):
            app.ffmpeg_manager.touch_stream(stream_id)

        # ‚úÖ OPTIMIZED: Faster retry with exponential backoff
        max_retries = 8  # Reduced from 10
        for retry in range(max_retries):
            if os.path.exists(file_path):
                break
            wait_time = min(0.05 * (2 ** retry), 1.0)  # Max 1s (was 2s)
            await asyncio.sleep(wait_time)
        
        if not os.path.exists(file_path):
            return web.Response(status=404, text="Segment not found")

        # ‚úÖ IMPROVED: Enhanced headers for WiFi stability
        headers = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, HEAD, OPTIONS",
            "Access-Control-Allow-Headers": "*",
            "Access-Control-Expose-Headers": "*",
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Connection": "keep-alive",
            "Keep-Alive": "timeout=300, max=1000",  # 5 min timeout
            "X-Accel-Buffering": "no",  # Disable nginx buffering if present
        }

        # Handle m3u8 playlists
        if filename.endswith('.m3u8'):
            try:
                content = ""
                # ‚úÖ Increased retries for playlist
                for attempt in range(5):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    if content.strip():
                        break
                    await asyncio.sleep(0.1)
                
                if not content.strip():
                    return web.Response(status=503, text="Playlist not ready")
                
                headers['Content-Type'] = 'application/vnd.apple.mpegurl'
                return web.Response(text=content, headers=headers)
            except Exception as e:
                logging.error(f"Error reading playlist {file_path}: {e}")
                return web.Response(status=500, text="Internal Server Error")

        # Handle TS segments with proper content type
        if filename.endswith('.ts'):
            headers['Content-Type'] = 'video/MP2T'
            headers['Accept-Ranges'] = 'bytes'
        
        # ‚úÖ IMPROVED: Stream file in chunks for better stability
        try:
            stat = os.stat(file_path)
            file_size = stat.st_size
            
            # Handle range requests properly
            range_header = request.headers.get('Range')
            if range_header:
                # Parse range header
                range_match = range_header.replace('bytes=', '').split('-')
                start = int(range_match[0]) if range_match[0] else 0
                end = int(range_match[1]) if len(range_match) > 1 and range_match[1] else file_size - 1
                
                headers['Content-Range'] = f'bytes {start}-{end}/{file_size}'
                headers['Content-Length'] = str(end - start + 1)
                
                response = web.StreamResponse(status=206, headers=headers)
                await response.prepare(request)
                
                with open(file_path, 'rb') as f:
                    f.seek(start)
                    remaining = end - start + 1
                    chunk_size = 128 * 1024  # 128KB chunks - faster streaming
                    
                    while remaining > 0:
                        chunk = f.read(min(chunk_size, remaining))
                        if not chunk:
                            break
                        await response.write(chunk)
                        remaining -= len(chunk)
                
                await response.write_eof()
                return response
            else:
                # No range request - send full file
                headers['Content-Length'] = str(file_size)
                return web.FileResponse(file_path, headers=headers, chunk_size=128*1024)
                
        except Exception as e:
            logging.error(f"Error serving segment {file_path}: {e}")
            return web.Response(status=500, text="Internal Server Error")

    app.router.add_get('/ffmpeg_stream/{stream_id}/{filename}', proxy_hls_stream)
    app.router.add_get('/proxy/ip', proxy.handle_proxy_ip)

    # Setup recording/DVR routes
    if DVR_ENABLED:
        setup_recording_routes(app, recording_manager)

    # CORS handler
    app.router.add_route('OPTIONS', '/{tail:.*}', proxy.handle_options)

    async def cleanup_handler(app):
        await proxy.cleanup()
    app.on_cleanup.append(cleanup_handler)

    async def on_startup(app):
        asyncio.create_task(ffmpeg_manager.cleanup_loop())
        if DVR_ENABLED:
            asyncio.create_task(recording_manager.cleanup_loop())
    app.on_startup.append(on_startup)

    async def on_shutdown(app):
        if DVR_ENABLED:
            await recording_manager.shutdown()
    app.on_shutdown.append(on_shutdown)

    return app

app = create_app()

def main():
    """Funzione principale per avviare il server."""
    if sys.platform == 'win32':
        logging.getLogger('asyncio').setLevel(logging.CRITICAL)

    hf_space = os.environ.get('SYSTEM') == 'spaces' or os.environ.get('HF_SPACE', 'false').lower() == 'true'

    print("=" * 60)
    if hf_space:
        print("üöÄ HF Space HLS Proxy - WiFi Optimized")
        print(f"üì° URL: https://umitm0d-pre.hf.space")
        print("‚öôÔ∏è Optimized for HF Space resources")
        print(f"üîß Port: {PORT}")
        print("=" * 60)
        try:
            from gunicorn.app.base import BaseApplication
            
            class HFApplication(BaseApplication):
                def __init__(self, app):
                    self.application = app
                    super().__init__()

                def load_config(self):
                    # ‚úÖ OPTIMIZED: Balanced timeouts for stability
                    self.cfg.set("bind", f"0.0.0.0:{PORT}")
                    self.cfg.set("workers", 2)  # ‚úÖ 2 workers for better performance
                    self.cfg.set("worker_class", "aiohttp.GunicornWebWorker")
                    self.cfg.set("timeout", 180)  # ‚úÖ 3 minutes
                    self.cfg.set("keepalive", 60)  # ‚úÖ 60s keepalive
                    self.cfg.set("graceful_timeout", 90)  # ‚úÖ Graceful shutdown
                    self.cfg.set("accesslog", None)
                    self.cfg.set("errorlog", "-")
                    self.cfg.set("loglevel", "warning")
                    self.cfg.set("preload_app", True)
                    self.cfg.set("worker_connections", 1000)
                    # ‚úÖ Request limits for memory management
                    self.cfg.set("max_requests", 10000)
                    self.cfg.set("max_requests_jitter", 1000)

                def load(self):
                    return self.application

            HFApplication(app).run()
        except ImportError as e:
            print(f"‚ö†Ô∏è Gunicorn not available: {e}, using aiohttp")
            web.run_app(
                app,
                host='0.0.0.0',
                port=PORT,
                access_log=None,
            )
    else:
        print("üöÄ HLS Proxy Server (Local Mode)")
        print(f"üì° http://localhost:{PORT}")
        
        try:
            import socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            wifi_ip = s.getsockname()[0]
            s.close()
            print(f"üì± http://{wifi_ip}:{PORT} (WiFi/LAN)")
            print(f"üí° On phone: Open browser to http://{wifi_ip}:{PORT}")
        except Exception as e:
            print(f"‚ö†Ô∏è Could not detect WiFi IP: {e}")
        
        print("=" * 60)
        print("üîó Available Endpoints:")
        print("  ‚Ä¢ / - Main page")
        print("  ‚Ä¢ /builder - Playlist builder")
        print("  ‚Ä¢ /info - Server info")
        if DVR_ENABLED:
            print("  ‚Ä¢ /recordings - DVR recordings")
        print("  ‚Ä¢ /proxy/hls/manifest.m3u8?url=<URL> - Stream proxy")
        print("  ‚Ä¢ /playlist?url=<definitions> - Playlist generator")
        print("=" * 60)
        
        web.run_app(app, host='0.0.0.0', port=PORT)

if __name__ == '__main__':
    main()